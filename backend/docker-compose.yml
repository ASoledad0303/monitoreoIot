version: "3.9"

services:
  #influxdb:
  #   image: influxdb:2.7
  #   container_name: influxdb
  #   ports:
  #     - "8086:8086"
  #  environment:
  #   DOCKER_INFLUXDB_INIT_MODE: ${DOCKER_INFLUXDB_INIT_MODE}
  #  DOCKER_INFLUXDB_INIT_USERNAME: ${DOCKER_INFLUXDB_INIT_USERNAME}
  #  DOCKER_INFLUXDB_INIT_PASSWORD: ${DOCKER_INFLUXDB_INIT_PASSWORD}
  #  DOCKER_INFLUXDB_INIT_ORG: ${DOCKER_INFLUXDB_INIT_ORG}
  #   DOCKER_INFLUXDB_INIT_BUCKET: ${DOCKER_INFLUXDB_INIT_BUCKET}
  #   DOCKER_INFLUXDB_INIT_RETENTION: ${DOCKER_INFLUXDB_INIT_RETENTION}
  #   DOCKER_INFLUXDB_INIT_ADMIN_TOKEN: ${DOCKER_INFLUXDB_INIT_ADMIN_TOKEN}
  #   INFLUXD_HTTP_BIND_ADDRESS: :8086
  #  volumes:
  #   - influxdb2-data:/var/lib/influxdb2
  #   - influxdb2-config:/etc/influxdb2
  # healthcheck:
  #   test: ["CMD-SHELL", "influx ping --host-url http://127.0.0.1:8086 >/dev/null 2>&1 || exit 1"]
  #   interval: 10s
  #   timeout: 5s
  #   retries: 60
  #   start_period: 120s
  # restart: unless-stopped

  postgres:
    image: postgres:15-alpine
    container_name: mypostgres
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-a.123456}
      POSTGRES_DB: ${POSTGRES_DB:-tesis_iot_db}
      PGDATA: /var/lib/postgresql/data/pgdata
    volumes:
      - postgres-data:/var/lib/postgresql/data
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "pg_isready -U ${POSTGRES_USER:-postgres} -d ${POSTGRES_DB:-tesis_iot_db}",
        ]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  mosquitto:
    image: eclipse-mosquitto:2
    container_name: mosquitto
    ports:
      - "1883:1883"
    volumes:
      - ./mosquitto/mosquitto.conf:/mosquitto/config/mosquitto.conf:ro
      - mosquitto-data:/mosquitto/data
      - ./mosquitto/passwords.txt:/mosquitto/config/passwords.txt:ro
      - mosquitto-log:/mosquitto/log
    environment:
      MQTT_USER: ${MQTT_USER:-tesis}
      MQTT_PASS: ${MQTT_PASS:-sE2wBB29123w}
    restart: unless-stopped

  # -----------------------------------------------------------------------------
  # Servicio Telegraf para recopilar y enviar métricas a InfluxDB y/o PostgreSQL
  # -----------------------------------------------------------------------------
  # telegraf:
  #   build:
  #     context: ./telegraf # Contexto del Docker build
  #     dockerfile: Dockerfile # Dockerfile a utilizar
  #   container_name: telegraf # Nombre del contenedor
  #   depends_on:
  #     # Dependencia comentada: espera a que InfluxDB esté saludable antes de iniciar
  #     # influxdb:
  #     #   condition: service_healthy
  #     mosquitto:
  #       condition: service_started # Espera a que Mosquitto haya arrancado
  #   volumes:
  #     - ./telegraf:/etc/telegraf:ro # Monta configuración de Telegraf (solo lectura)
  #   environment:
  #     INFLUXDB_URL: ${INFLUXDB_URL} # URL de InfluxDB (env)
  #     INFLUXDB_TOKEN: ${INFLUXDB_TOKEN} # Token de autentificación para InfluxDB
  #     INFLUXDB_ORG: ${INFLUXDB_ORG} # Organización InfluxDB
  #     INFLUXDB_BUCKET: ${INFLUXDB_BUCKET} # Bucket InfluxDB
  #     # Autenticación con MQTT (broker)
  #     MQTT_USER: ${MQTT_USER:-tesis} # Usuario MQTT (por defecto: 'tesis')
  #     MQTT_PASS: ${MQTT_PASS:-sE2wBB29123w} # Password MQTT (por defecto: valor fuerte)
  #     # Opcional: PostgreSQL - se puede utilizar DATABASE_URL o variables individuales
  #     # NOTA: Para acceso desde Docker usa 'host.docker.internal' en vez de localhost
  #     # Ejemplo de conexión: postgresql://postgres:a.123456@host.docker.internal:5432/tesis_iot_db
  #     DATABASE_URL: ${DATABASE_URL:-postgresql://postgres:a.123456@host.docker.internal:5432/tesis_iot_db}
  #     POSTGRES_HOST: ${POSTGRES_HOST:-host.docker.internal} # Host base de datos PostgreSQL
  #     POSTGRES_PORT: ${POSTGRES_PORT:-5432} # Puerto base de datos PostgreSQL
  #     POSTGRES_DB: ${POSTGRES_DB:-tesis_iot_db} # Nombre de la base de datos
  #     POSTGRES_USER: ${POSTGRES_USER:-postgres} # Usuario PostgreSQL
  #     POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-a.123456} # Password PostgreSQL
  #   # Para Linux: es necesario configurar esto o usar network_mode: "host"
  #   extra_hosts:
  #     - "host.docker.internal:host-gateway" # Soporta redirección de host local en Docker Linux
  #   restart: unless-stopped # Reinicia el contenedor salvo detención manual

  # -----------------------------------------------------------------------------
  # Servicio Emulator: simula un ESP enviando mensajes MQTT cada X segundos
  # -----------------------------------------------------------------------------
  # emulator:
  #   image: python:3.11-alpine # Imagen base de Python liviana
  #   container_name: esp-emulator # Nombre del contenedor
  #   depends_on:
  #     mosquitto:
  #       condition: service_started # Espera a que el broker MQTT esté iniciado
  #   command: [
  #       "sh",
  #       "-c",
  #       "pip install --no-cache-dir paho-mqtt && python /app/emulator.py",
  #     ] # Instala librería MQTT y ejecuta el emulador Python
  #   environment:
  #     MQTT_BROKER: mosquitto # Dirección del broker MQTT (nombre del servicio)
  #     MQTT_PORT: 1883 # Puerto por defecto de MQTT
  #     MQTT_BASE: ${MQTT_BASE:-tesis/iot/esp32} # Base Topic MQTT para los mensajes
  #     MQTT_USER: ${MQTT_USER:-tesis} # Usuario MQTT (por defecto: 'tesis')
  #     MQTT_PASS: ${MQTT_PASS:-sE2wBB29123w} # Password MQTT (por defecto fuerte)
  #   volumes:
  #     - ./emulator.py:/app/emulator.py:ro # Monta el script Python de emulación (solo lectura)
  #   restart: unless-stopped # Reinicia salvo detención manual

  backend:
    build:
      context: ./api
      dockerfile: Dockerfile
    container_name: iot-backend
    depends_on:
      postgres:
        condition: service_healthy
      mosquitto:
        condition: service_started
      # influxdb:
      # condition: service_healthy
    environment:
      # API (Flask)
      PORT: ${API_PORT:-5000}
      FLASK_ENV: production

      # MQTT para lectura en tiempo real
      MQTT_BROKER: mosquitto
      MQTT_PORT: 1883
      MQTT_BASE: ${MQTT_BASE:-tesis/iot/esp32}
      MQTT_USER: ${MQTT_USER:-tesis}
      MQTT_PASS: ${MQTT_PASS:-sE2wBB29123w}

      # (Opcional) InfluxDB si luego querés consultas históricas desde la API
      INFLUXDB_URL: ${INFLUXDB_URL}
      INFLUXDB_TOKEN: ${INFLUXDB_TOKEN}
      INFLUXDB_ORG: ${INFLUXDB_ORG}
      INFLUXDB_BUCKET: ${INFLUXDB_BUCKET}

      # PostgreSQL para consultas históricas (>30 días)
      # Usar el nombre del servicio 'postgres' para conexión dentro de Docker
      # Usar variables individuales (el código construye DATABASE_URL si es necesario)
      POSTGRES_HOST: ${POSTGRES_HOST:-postgres}
      POSTGRES_PORT: ${POSTGRES_PORT:-5432}
      POSTGRES_DB: ${POSTGRES_DB:-tesis_iot_db}
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-a.123456}

      # Buffer de muestras
      SAMPLES_BUFFER_SIZE: 2000
    ports:
      - "${API_PORT:-5000}:5000"
    restart: unless-stopped

  frontend:
    build:
      context: ..
      dockerfile: Dockerfile
      args:
        # URLs para build time (NEXT_PUBLIC_* se inyectan en el código del cliente)
        # ⚠️ IMPORTANTE: Estas URLs se usan desde el NAVEGADOR del usuario, NO desde dentro del contenedor
        #
        # ¿Por qué usar la IP pública y no "backend"?
        # - El código JavaScript se ejecuta en el navegador del usuario
        # - El navegador accede al frontend y hace requests al backend
        # - Desde el navegador, "backend" no existe (solo existe en la red interna de Docker)
        # - Usar la IP pública o dominio para acceso desde cualquier lugar
        NEXT_PUBLIC_FLASK_API_URL: ${NEXT_PUBLIC_FLASK_API_URL:-http://138.197.237.23:5000}
        NEXT_PUBLIC_WS_URL: ${NEXT_PUBLIC_WS_URL:-ws://138.197.237.23:5000/ws}
    container_name: iot-frontend
    depends_on:
      postgres:
        condition: service_healthy
      backend:
        condition: service_started
    environment:
      # Puerto del frontend
      PORT: ${FRONTEND_PORT:-3000}
      NODE_ENV: production
      COMPANY_ENABLED: true
      # URLs del backend (para referencia, aunque el código usa NEXT_PUBLIC_*)
      BACKEND_URL: ${BACKEND_URL:-http://backend:5000}
      BACKEND_PORT: ${API_PORT:-5000}
      # PostgreSQL - para las API routes de Next.js que se ejecutan en el servidor
      # Usar el nombre del servicio 'postgres' para conexión dentro de Docker
      # Usar variables individuales (el código en src/lib/db.ts las usa correctamente)
      PGHOST: ${POSTGRES_HOST:-postgres}
      PGPORT: ${POSTGRES_PORT:-5432}
      PGDATABASE: ${POSTGRES_DB:-tesis_iot_db}
      PGUSER: ${POSTGRES_USER:-postgres}
      PGPASSWORD: ${POSTGRES_PASSWORD:-a.123456}
      # SMTP - Configuración de correo electrónico (Gmail)
      SMTP_HOST: ${SMTP_HOST:-smtp.gmail.com}
      SMTP_PORT: ${SMTP_PORT:-587}
      SMTP_USER: ${SMTP_USER:-unidatesis@gmail.com}
      SMTP_PASS: ${SMTP_PASS:-fahi snuv ymnn haez}
      MAIL_FROM: ${MAIL_FROM:-unidatesis@gmail.com}
    ports:
      - "${FRONTEND_PORT:-3000}:3000"
    restart: unless-stopped

  email-worker:
    image: node:20-alpine
    container_name: iot-email-worker
    # depends_on:
    #    postgres:
    #     condition: service_healthy
    working_dir: /app
    volumes:
      - ../scripts:/app/scripts:ro
      - ../package.json:/app/package.json:ro
      - ../package-lock.json:/app/package-lock.json.host:ro
      - email-worker-node-modules:/app/node_modules
    environment:
      # PostgreSQL - para conexión a la base de datos
      PGHOST: ${POSTGRES_HOST:-postgres}
      PGPORT: ${POSTGRES_PORT:-5432}
      PGDATABASE: ${POSTGRES_DB:-tesis_iot_db}
      PGUSER: ${POSTGRES_USER:-postgres}
      PGPASSWORD: ${POSTGRES_PASSWORD:-a.123456}
      # SMTP - Configuración de correo electrónico
      SMTP_HOST: ${SMTP_HOST:-smtp.gmail.com}
      SMTP_PORT: ${SMTP_PORT:-587}
      SMTP_USER: ${SMTP_USER:-unidatesis@gmail.com}
      SMTP_PASS: ${SMTP_PASS:-fahi snuv ymnn haez}
      MAIL_FROM: ${MAIL_FROM:-unidatesis@gmail.com}
    command: sh -c "if [ -f /app/package-lock.json.host ]; then cp /app/package-lock.json.host /app/package-lock.json; fi && npm install && node scripts/email-worker.js"
    restart: unless-stopped

volumes:
  influxdb2-data:
  influxdb2-config:
  postgres-data:
  mosquitto-data:
  mosquitto-log:
  email-worker-node-modules:
