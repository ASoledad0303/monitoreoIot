[agent]
  interval = "5s"
  round_interval = true
  metric_batch_size = 1000
  metric_buffer_limit = 10000
  collection_jitter = "0s"
  flush_interval = "5s"
  flush_jitter = "0s"
  logfile = ""

###############################################################################
# INPUT: MQTT (Lee del emulador)
###############################################################################
[[inputs.mqtt_consumer]]
  servers = ["tcp://mosquitto:1883"]
  username = "tesis"
  password = "@E2wBB29|23w"
  topics = [
    "esp/energia/+/state",  # Nuevo formato: esp/energia/{device_id}/state
    # Tópicos antiguos (mantenidos por compatibilidad)
    "tesis/iot/esp32/metrics/vrms",
    "tesis/iot/esp32/metrics/irms",
    "tesis/iot/esp32/metrics/s_apparent",
    "tesis/iot/esp32/telemetry",
    "esp/energia/state",
  ]
  qos = 0
  connection_timeout = "30s"
  persistent_session = false
  client_id = "telegraf-mqtt"
  data_format = "json"
  # Si el payload tiene "ts" como epoch ms, usalo como timestamp:
  # Comentado porque los mensajes no siempre tienen "ts"
  # json_time_key = "ts"
  # json_time_format = "unix_ms"
  # Campos string (device es string)
  json_string_fields = ["device"]
  # Mapeo de campos del nuevo formato:
  # V -> vrms, I -> irms, P -> potencia_activa, S -> s_apparent_va, PF -> factor_potencia
  # Puedes forzar un measurement por tópico:
  # measurement_name_override = "esp32_metrics"
  # O derivar por tópico:
  # Para el nuevo formato esp/energia/+/state, usar measurement override
  # El wildcard + captura el device_id
  [[inputs.mqtt_consumer.topic_parsing]]
    topic = "esp/energia/+/state"
    measurement = "telemetry"
    # Extraer device del JSON (ya está en json_string_fields)
    # Los campos V, I, P, S, PF se mapearán automáticamente como campos numéricos
    # El campo "device" se tratará como tag automáticamente si está en json_string_fields
  [[inputs.mqtt_consumer.topic_parsing]]
    topic = "tesis/iot/esp32/metrics/vrms"
    measurement = "vrms"
  [[inputs.mqtt_consumer.topic_parsing]]
    topic = "tesis/iot/esp32/metrics/irms"
    measurement = "irms"
  [[inputs.mqtt_consumer.topic_parsing]]
    topic = "tesis/iot/esp32/metrics/s_apparent"
    measurement = "s_apparent"
  [[inputs.mqtt_consumer.topic_parsing]]
    topic = "tesis/iot/esp32/telemetry"
    measurement = "telemetry"

###############################################################################
# PROCESADORES: Renombrar campos del nuevo formato
###############################################################################
# Renombrar campos V, I, P, S, PF del nuevo formato esp/energia/+/state
# Solo renombra si los campos existen (no afecta otros measurements)
[[processors.rename]]
  [[processors.rename.replace]]
    field = "V"
    dest = "vrms"
  [[processors.rename.replace]]
    field = "I"
    dest = "irms"
  [[processors.rename.replace]]
    field = "P"
    dest = "potencia_activa"
  [[processors.rename.replace]]
    field = "S"
    dest = "s_apparent_va"
  [[processors.rename.replace]]
    field = "PF"
    dest = "factor_potencia"

###############################################################################
# OUTPUT: InfluxDB v2 (últimos 30 días con retention policy)
###############################################################################
[[outputs.influxdb_v2]]
  urls = ["${INFLUXDB_URL}"]          # ej: http://influxdb:8086
  token = "${INFLUXDB_TOKEN}"
  organization = "${INFLUXDB_ORG}"
  bucket = "${INFLUXDB_BUCKET}"

###############################################################################
# OUTPUT: PostgreSQL (histórico completo)
# Telegraf escribe simultáneamente a ambos outputs en cada flush_interval (5s)
# Usamos outputs.execd con script Python porque outputs.postgresql no está disponible
# Solo enviamos el measurement "telemetry" a PostgreSQL
###############################################################################
[[outputs.execd]]
  command = ["python3", "/etc/telegraf/postgres_writer.py"]
  data_format = "influx"
  restart_delay = "10s"
  # Enviar todos los measurements, el script filtrará "telemetry" y "esp"

# OUTPUT temporal para debug - ver qué datos genera Telegraf
[[outputs.file]]
  files = ["/tmp/telegraf_debug.txt"]
  data_format = "influx"
